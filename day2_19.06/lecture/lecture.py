# Использования numpy
# Импорт бибоиотеки 
import numpy as np

# Создание массива из нулей
x = np.zeros((10,2)) # массив 10 на 2
# Сохранение массива в файл
np.savetxt(fname = 'day2_19.06/lecture/zeros.csv', X = x)
# Чтение массива из файла
y = np.loadtxt(fname='day2_19.06/lecture/zeros.csv')
y

# внутри записанного файла находятся числа в экспоненциальной записи, которые разделены пробелами
# head -2 day2_19.06/zeros.csv
# 0.000000000000000000e+00 0.000000000000000000e+00
# 0.000000000000000000e+00 0.000000000000000000e+00

# для удобства открытия файлов во внешней среде лучше использовать дополнительные аргументы при сохранении файла

np.savetxt(
    fname = 'day2_19.06/lecture/zeros.csv', 
    X = x,
    fmt = '%1.1i', 
    # Сохраняем int, 
    # 1 Минимальное количество символов для записи
    # 1 Минимальное количество цифр, которые будут использованы для записи целочисленных данных
    # i Десятичное целое число со знаком,
    delimiter = ','
)
# head -2 day2_19.06/zeros.csv
# 0,0
# 0,0

y = np.loadtxt(
    fname='day2_19.06/lecture/zeros.csv',
    delimiter = ','
)
y

# Другие способы заполнения массивов
# Массив единиц
np.ones((3,5))
# Единичная матрица
np.eye(
    N=3, # Число строк
    M=5 # Число столбцов
)
# Случайные числа int
np.random.randint(
    100, # low, если не указано верхнее значение, то выбираются число [0, low)
    size=(3,5)
)
# help(np.random.randint)

# Выборка 10 элементов из массива [0,1]
np.random.choice([0,1], 10, replace = True)


# Другой способ создания единичной матрицы (КВАДРАТНОЙ)
a = np.identity(3)
# Создание массива по аналогии (*_like)
# Заполнить случайными значениями из памяти
np.empty_like(a)
# Заполнить единицами
np.ones_like(a)
# Заполнить нулями
np.zeros_like(a)
# Заполнить каким-то значением
np.full_like(a, 1/2)

# Действия над матрицами
x = np.ones((3,3))
y = np.ones((3,3))
x + y
x - 2*y
# Операции можно совершать только над массивами одинаковых размерностей

# Умножение матриц
x = np.random.randint(100, size=(3,3))
y = np.random.randint(100, size=(3,3))
x*y # Перемножились значения элементов матриц, а не матрицы
x@y            # Матричное умножение
x.dot(y)       # Матричное умножение
np.dot(x,y)    # Матричное умножение
np.matmul(x,y) # Матричное умножение

x = np.random.randint(3, size = (3,3))
y = np.array([1,2,3])
x*y # Перемножили каждый столбец на свой множитель
y*x # Тоже самое

# Приведение массива к вектору
x.flatten()
x.ravel()
# flatten отличается от reval тем, что первый возвращает копию массива, а второй только вид массива. Значит reval не тратит память и быстрее

# Поворот массива
x
np.rot90(x)